// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GeoServiceClient is the client API for GeoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GeoServiceClient interface {
	ListCountry(ctx context.Context, in *CountryListRequest, opts ...grpc.CallOption) (*CountryListResponse, error)
	ListRegion(ctx context.Context, in *RegionListRequest, opts ...grpc.CallOption) (*RegionListResponse, error)
	ListCity(ctx context.Context, in *CityListRequest, opts ...grpc.CallOption) (*CityListResponse, error)
	GetCity(ctx context.Context, in *GetCityRequest, opts ...grpc.CallOption) (*City, error)
	GetCountry(ctx context.Context, in *GetCountryRequest, opts ...grpc.CallOption) (*Country, error)
	GetRegion(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*Region, error)
}

type geoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGeoServiceClient(cc grpc.ClientConnInterface) GeoServiceClient {
	return &geoServiceClient{cc}
}

func (c *geoServiceClient) ListCountry(ctx context.Context, in *CountryListRequest, opts ...grpc.CallOption) (*CountryListResponse, error) {
	out := new(CountryListResponse)
	err := c.cc.Invoke(ctx, "/api.GeoService/ListCountry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoServiceClient) ListRegion(ctx context.Context, in *RegionListRequest, opts ...grpc.CallOption) (*RegionListResponse, error) {
	out := new(RegionListResponse)
	err := c.cc.Invoke(ctx, "/api.GeoService/ListRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoServiceClient) ListCity(ctx context.Context, in *CityListRequest, opts ...grpc.CallOption) (*CityListResponse, error) {
	out := new(CityListResponse)
	err := c.cc.Invoke(ctx, "/api.GeoService/ListCity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoServiceClient) GetCity(ctx context.Context, in *GetCityRequest, opts ...grpc.CallOption) (*City, error) {
	out := new(City)
	err := c.cc.Invoke(ctx, "/api.GeoService/GetCity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoServiceClient) GetCountry(ctx context.Context, in *GetCountryRequest, opts ...grpc.CallOption) (*Country, error) {
	out := new(Country)
	err := c.cc.Invoke(ctx, "/api.GeoService/GetCountry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoServiceClient) GetRegion(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*Region, error) {
	out := new(Region)
	err := c.cc.Invoke(ctx, "/api.GeoService/GetRegion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GeoServiceServer is the server API for GeoService service.
// All implementations must embed UnimplementedGeoServiceServer
// for forward compatibility
type GeoServiceServer interface {
	ListCountry(context.Context, *CountryListRequest) (*CountryListResponse, error)
	ListRegion(context.Context, *RegionListRequest) (*RegionListResponse, error)
	ListCity(context.Context, *CityListRequest) (*CityListResponse, error)
	GetCity(context.Context, *GetCityRequest) (*City, error)
	GetCountry(context.Context, *GetCountryRequest) (*Country, error)
	GetRegion(context.Context, *GetRegionRequest) (*Region, error)
	mustEmbedUnimplementedGeoServiceServer()
}

// UnimplementedGeoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGeoServiceServer struct {
}

func (UnimplementedGeoServiceServer) ListCountry(context.Context, *CountryListRequest) (*CountryListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCountry not implemented")
}
func (UnimplementedGeoServiceServer) ListRegion(context.Context, *RegionListRequest) (*RegionListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRegion not implemented")
}
func (UnimplementedGeoServiceServer) ListCity(context.Context, *CityListRequest) (*CityListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCity not implemented")
}
func (UnimplementedGeoServiceServer) GetCity(context.Context, *GetCityRequest) (*City, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCity not implemented")
}
func (UnimplementedGeoServiceServer) GetCountry(context.Context, *GetCountryRequest) (*Country, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCountry not implemented")
}
func (UnimplementedGeoServiceServer) GetRegion(context.Context, *GetRegionRequest) (*Region, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegion not implemented")
}
func (UnimplementedGeoServiceServer) mustEmbedUnimplementedGeoServiceServer() {}

// UnsafeGeoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GeoServiceServer will
// result in compilation errors.
type UnsafeGeoServiceServer interface {
	mustEmbedUnimplementedGeoServiceServer()
}

func RegisterGeoServiceServer(s grpc.ServiceRegistrar, srv GeoServiceServer) {
	s.RegisterService(&GeoService_ServiceDesc, srv)
}

func _GeoService_ListCountry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountryListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServiceServer).ListCountry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.GeoService/ListCountry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServiceServer).ListCountry(ctx, req.(*CountryListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoService_ListRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServiceServer).ListRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.GeoService/ListRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServiceServer).ListRegion(ctx, req.(*RegionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoService_ListCity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CityListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServiceServer).ListCity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.GeoService/ListCity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServiceServer).ListCity(ctx, req.(*CityListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoService_GetCity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServiceServer).GetCity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.GeoService/GetCity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServiceServer).GetCity(ctx, req.(*GetCityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoService_GetCountry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCountryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServiceServer).GetCountry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.GeoService/GetCountry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServiceServer).GetCountry(ctx, req.(*GetCountryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoService_GetRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServiceServer).GetRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.GeoService/GetRegion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServiceServer).GetRegion(ctx, req.(*GetRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GeoService_ServiceDesc is the grpc.ServiceDesc for GeoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GeoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.GeoService",
	HandlerType: (*GeoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListCountry",
			Handler:    _GeoService_ListCountry_Handler,
		},
		{
			MethodName: "ListRegion",
			Handler:    _GeoService_ListRegion_Handler,
		},
		{
			MethodName: "ListCity",
			Handler:    _GeoService_ListCity_Handler,
		},
		{
			MethodName: "GetCity",
			Handler:    _GeoService_GetCity_Handler,
		},
		{
			MethodName: "GetCountry",
			Handler:    _GeoService_GetCountry_Handler,
		},
		{
			MethodName: "GetRegion",
			Handler:    _GeoService_GetRegion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "geo_service.proto",
}
